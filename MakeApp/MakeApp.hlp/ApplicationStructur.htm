<!doctype html>
<html><!-- InstanceBegin template="/Templates/OneColumnPage.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta charset="utf-8">
<!-- InstanceBeginEditable name="doctitle" -->
<title>Application Template Organization</title>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="head" -->
<!-- InstanceEndEditable -->
<link href="App.css" rel="stylesheet" type="text/css">
</head>

<body>

<div class="container">
<div class="content">
<!-- InstanceBeginEditable name="Title" -->
<h1>Application Template Organization</h1>
<!-- InstanceEndEditable -->

<!-- InstanceBeginEditable name="Body" -->
<h2></h2>
<p>
</p>
<h2>Introduction</h2>
<p>
When I have approached an idea for an application in Windows I have settled on Microsoft Foundation Class (MFC)
as the starting point.  Most of the applications are simple in that they require only one "document".  There may
be one or more load components, store components, display components, print components and some processing before, during or after any of these components.  Some applications start with a blank window, some may start with
a dialog box.
</p>

<p>
Applications may just start, process, and finish without human intervention.  Others need input from humans in
the form of requests or commands.  Some of these request require the human to input data and in the MFC world that
is usually done in a dialog box or edit window or windows somewhere in the window controlled by the application.
</p>

<h3>The Basic MFC Application Organization</h3>
<p>
If one uses Visual Studio to create a new application and just creates a minimal app without too many bells and
whistles four main modules (classes) are created:
</p>
<ul>
<li><a href="CApp.htm">Application</a></li>
<li><a href="CMainFrm.htm">Main Frame</a></li>
<li><a href="CDoc.htm">Document</a></li>
<li><a href="CScrView.htm">View</a></li>
</ul>
<p>
While not a Microsoft Engineer the following is my understanding of the purpose and utility of each module.
The Application module is the starting point, contains some initialization, creates the Main Frame, Document and View objects and starts message handling.  Messages are the fluid in the MFC world for moving data around among
the basic modules of the program.
</p>
<p>
The Main Frame module constructs the window components that we see on the screen.  Components such as the border,
the menu bar, the tool bar, the status border at the bottom of the window and the blank window.  It manages
the window's position on the screen and the window's size.  Since messages are generated by left mouse and right
mouse clicks on components of the menu and tool bar this module must initialize that process also.  The library
contains a Toolbar module that allows one to add buttons and drop down lists to the toolbar.  Some of those 
features are described in the <a href="CMainFrm.htm">CMainFrm Module</a>. 
</p>
<p>
The "document" object appears to be the place where most of the commands and some of the processing should be handled but that is just my opinion.  In most of my applications I handle the initial command response in
the document module but quickly transfer control to the actual processing to the domain that is intimately involved with nature of the processing.  Note that the "serialize" function is intended to do loading and 
storing and that functionality (although changed) supports the notion that commands are to be handled in the
"document" module.  A description of the serialization process is found in the "<a href="Serialize.htm">Serialize Operations</a>" discussion.
</p>
<p>
The "view" object by its very name has something to do with the display and printing that application needs to
do.  But as I've learned over time, this is not as easy as it sounds.  Back when I started in this business the
output medium was a roll of paper.  Output was done by sending characters to that paper.  This was really easy
to do and output statements were placed in line with the code gathering the output.  We only needed to worry about
the width of the paper and that was accomplished by counting characters, only 80 or a bit fewer would fit as
there was only one font, the print head on the device.  Now there may be as many as 900 different fonts, most of
which are variable length, the window itself may be any size, wide and short, narrow and long, medium and medium.
So how does one manage to make a presentable output with so many variables.  My answer has been to separate the
output generation from the output presentation. A discussion of the organization of the program for printing is
contained in the <a href="DisplayOrPrintOps.htm">Display or Print Operations</a> page. 
</p>
<p>
Over the years I've tried various schemes to tame the application.  The version of the schemes used in the
template involves base classes for all four main components with commonly used features in the base classes.
Other sections describe the gist of the base classes and how 
<a href="Serialize.htm">load and store data from/to a file</a> and 
<a href="DisplayOrPrintOps.htm">how output to the display and printer</a> is accomplished.  Output should be
easy and it almost is with the organization suggested herein. 
</p>
<!-- InstanceEndEditable -->
</div><!-- end .content -->
</div><!-- end .container -->
</body>
<!-- InstanceEnd --></html>
